{
  "cells": [
    {
      "cell_type": "code",
      "execution_count": 2,
      "id": "d99ca023",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "d99ca023",
        "outputId": "71de113f-cdb8-426e-ed7d-72ed0ae535fd"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Requirement already satisfied: tqdm in /usr/local/lib/python3.10/dist-packages (4.66.4)\n"
          ]
        }
      ],
      "source": [
        "import scipy\n",
        "from scipy.optimize import minimize\n",
        "import numpy as np\n",
        "import math\n",
        "import itertools\n",
        "import time\n",
        "from itertools import product\n",
        "import pandas as pd\n",
        "!pip install tqdm\n",
        "from tqdm.notebook import trange,tqdm"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 3,
      "id": "wvdrtNyQYV4m",
      "metadata": {
        "id": "wvdrtNyQYV4m"
      },
      "outputs": [],
      "source": [
        "def convert_lambdas_to_prices(lambdas, inverse_demand_func):\n",
        "  prices = []\n",
        "  for rate in lambdas:\n",
        "    prices.append(float(inverse_demand_func(rate)))\n",
        "  return prices"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 4,
      "id": "cMZQoahSMgSK",
      "metadata": {
        "id": "cMZQoahSMgSK"
      },
      "outputs": [],
      "source": [
        "def compute_steady_state(lambdas, NUM_SERVERS):\n",
        "  mus = [min(NUM_SERVERS,i) for i in range(len(lambdas)+1)]\n",
        "  lambda_mu_ratios = [lambdas[i]/mus[i+1] for i in range(len(lambdas))]\n",
        "  denominator = np.sum([np.product(lambda_mu_ratios[0:k]) for k in range(len(lambdas)+1)])\n",
        "  steady_state = [np.product(lambda_mu_ratios[0:k])/denominator  for k in range(len(lambdas)+1)]\n",
        "  return steady_state"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 5,
      "id": "f729170e",
      "metadata": {
        "id": "f729170e"
      },
      "outputs": [],
      "source": [
        "def construct_function(inverse_demand_func, NUM_SERVERS, congestion_or_sojourn):\n",
        "    if congestion_or_sojourn == 'congestion':\n",
        "      def negative_func(lambdas):\n",
        "          mus = [min(NUM_SERVERS,i) for i in range(len(lambdas)+1)]\n",
        "\n",
        "          lambda_mu_ratios = [lambdas[i]/mus[i+1] for i in range(len(lambdas))]\n",
        "\n",
        "          denominator = np.sum([np.product(lambda_mu_ratios[0:k]) for k in range(len(lambdas)+1)])\n",
        "\n",
        "          numerator_sum_terms = []\n",
        "          for i in range(len(lambdas)):\n",
        "              expected_cost = 1/NUM_SERVERS * (i+1) if i >= NUM_SERVERS else 1\n",
        "\n",
        "              if abs(lambdas[i])>1e-12:\n",
        "                term = (inverse_demand_func(lambdas[i])-expected_cost) * lambdas[i] * np.product(lambda_mu_ratios[0:i])\n",
        "              else:\n",
        "                term = 0\n",
        "              numerator_sum_terms.append(term)\n",
        "\n",
        "          # Convert each element in numerator_sum_terms to a NumPy array\n",
        "          numerator_sum_terms = [np.array(item).flatten() if isinstance(item, np.ndarray) else np.array([item]) for item in numerator_sum_terms]\n",
        "\n",
        "\n",
        "          # Convert list of arrays to a 2D NumPy array (if necessary)\n",
        "          numerator_sum_terms = np.vstack(numerator_sum_terms)\n",
        "\n",
        "          # Sum across the rows if each term is supposed to be summed individually\n",
        "          sum_terms = np.sum(numerator_sum_terms, axis=0)  # Adjust axis if necessary\n",
        "\n",
        "          return -1 * sum_terms / denominator\n",
        "\n",
        "\n",
        "      return negative_func\n",
        "    if congestion_or_sojourn == 'sojourn':\n",
        "      def negative_sojourn_func(lambdas):\n",
        "          if lambdas[0] == 0:\n",
        "            return 0\n",
        "\n",
        "          steady_state = compute_steady_state(lambdas,NUM_SERVERS)\n",
        "\n",
        "          blocking_prob = steady_state[-1]\n",
        "\n",
        "          elmachtoub_rate = np.dot(lambdas,steady_state[0:-1])\n",
        "\n",
        "          #print(lambdas)\n",
        "          #print(elmachtoub_rate)\n",
        "          #print([inverse_demand_func(lambdas[i]) for i in range(len(lambdas))])\n",
        "\n",
        "          if elmachtoub_rate == 0:\n",
        "            return 0\n",
        "\n",
        "          vector_of_reward_rates = np.array([lambdas[i] * inverse_demand_func(lambdas[i]) - i / elmachtoub_rate for i in range(len(lambdas))])\n",
        "\n",
        "          # Ensure steady_state and vector_of_reward_rates are 1D arrays\n",
        "          steady_state = np.array(steady_state[:-1]).flatten()\n",
        "          vector_of_reward_rates = vector_of_reward_rates.flatten()\n",
        "\n",
        "          #print(steady_state)\n",
        "          #print(vector_of_reward_rates)\n",
        "          #print(elmachtoub_rate)\n",
        "          #print(-1 * np.dot(vector_of_reward_rates, steady_state))\n",
        "          #print(len(lambdas) / elmachtoub_rate * blocking_prob)\n",
        "\n",
        "          # Return the negative dot product of vector_of_reward_rates and steady_state\n",
        "          return -1 * np.dot(vector_of_reward_rates, steady_state) + len(lambdas) / elmachtoub_rate * blocking_prob\n",
        "\n",
        "      return negative_sojourn_func\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 6,
      "id": "d8b270a6",
      "metadata": {
        "id": "d8b270a6"
      },
      "outputs": [],
      "source": [
        " def construct_static_function(inverse_demand_func, cutoff, NUM_SERVERS, congestion_or_sojourn):\n",
        "    if congestion_or_sojourn == 'congestion':\n",
        "      def negative_func(arrival_rate):\n",
        "          arrival_rate = arrival_rate[0]\n",
        "\n",
        "          lambdas = [arrival_rate for i in range(cutoff+1)]\n",
        "\n",
        "          mus = [min(NUM_SERVERS,i) for i in range(len(lambdas)+1)]\n",
        "\n",
        "          lambda_mu_ratios = [lambdas[i]/mus[i+1] for i in range(len(lambdas))]\n",
        "\n",
        "          denominator = np.sum([np.product(lambda_mu_ratios[0:k]) for k in range(len(lambdas)+1)])\n",
        "\n",
        "          numerator_sum_terms = []\n",
        "          for i in range(len(lambdas)):\n",
        "              expected_cost = 1/NUM_SERVERS * (i+1) if i >= NUM_SERVERS else 1\n",
        "              if lambdas[i]:\n",
        "                term = (inverse_demand_func(lambdas[i])-expected_cost) * lambdas[i] * np.product(lambda_mu_ratios[0:i])\n",
        "              else:\n",
        "                term = 0\n",
        "              numerator_sum_terms.append(term)\n",
        "\n",
        "          return -1*np.sum(numerator_sum_terms)/denominator\n",
        "\n",
        "      return negative_func\n",
        "    if congestion_or_sojourn == 'sojourn':\n",
        "      def negative_sojourn_func(arrival_rate):\n",
        "\n",
        "          if arrival_rate == 0:\n",
        "            return 0\n",
        "\n",
        "          arrival_rate = arrival_rate[0]\n",
        "\n",
        "\n",
        "\n",
        "          lambdas = [arrival_rate for i in range(cutoff+1)]\n",
        "\n",
        "          steady_state = compute_steady_state(lambdas,NUM_SERVERS)\n",
        "\n",
        "          blocking_prob = steady_state[-1]\n",
        "\n",
        "          elmachtoub_rate = np.dot(lambdas,steady_state[0:-1])\n",
        "\n",
        "          if elmachtoub_rate == 0:\n",
        "            return 0\n",
        "\n",
        "\n",
        "          vector_of_reward_rates = [lambdas[i]*inverse_demand_func(lambdas[i]) - i/elmachtoub_rate for i in range(len(lambdas))]\n",
        "          vector_of_reward_rates = np.array(vector_of_reward_rates).flatten()  # Ensure it is 1D\n",
        "\n",
        "          steady_state = np.array(steady_state[:-1]).flatten()  # Ensure steady_state is 1D\n",
        "          return -1*np.dot(vector_of_reward_rates, steady_state)+len(lambdas)/elmachtoub_rate * blocking_prob\n",
        "\n",
        "      return negative_sojourn_func\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 7,
      "id": "TIlM_jpGwvD2",
      "metadata": {
        "id": "TIlM_jpGwvD2"
      },
      "outputs": [],
      "source": [
        "def compute_optimal_static_policy_given_rate(inverse_demand_func, MAX_QUEUE, arrival_rate, NUM_SERVERS, congestion_or_sojourn):\n",
        "  profit_vals = []\n",
        "  for cutoff in range(MAX_QUEUE):\n",
        "    static_func = construct_static_function(inverse_demand_func,cutoff, NUM_SERVERS, congestion_or_sojourn)\n",
        "    profit_vals.append(-1*static_func(arrival_rate))\n",
        "\n",
        "  best_cutoff = np.argmax(profit_vals)\n",
        "\n",
        "  return [arrival_rate[0] if i < best_cutoff+1 else 0 for i in range(MAX_QUEUE)]\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 8,
      "id": "772vW2ZNzPMw",
      "metadata": {
        "id": "772vW2ZNzPMw"
      },
      "outputs": [],
      "source": [
        "def compute_optimal_static_policy(inverse_demand_func, MAX_QUEUE, NUM_SERVERS, MAX_RATE, congestion_or_sojourn):\n",
        "    max_so_far = -np.inf\n",
        "    for cutoff in range(MAX_QUEUE):\n",
        "        static_func = construct_static_function(inverse_demand_func,cutoff,NUM_SERVERS, congestion_or_sojourn)\n",
        "        bounds = [(0, MAX_RATE)]\n",
        "        initial_sol = [MAX_RATE[0]/2]\n",
        "        res = minimize(static_func, initial_sol, bounds = bounds, options = {'maxfun': 30000})\n",
        "        if -1*res.fun >= max_so_far:\n",
        "          max_so_far = -1*res.fun\n",
        "          best_rate = res.x\n",
        "          best_cutoff = cutoff\n",
        "\n",
        "    return [best_rate[0] if i < best_cutoff+1 else 0 for i in range(MAX_QUEUE)]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 9,
      "id": "_2y8YQhz6wOO",
      "metadata": {
        "id": "_2y8YQhz6wOO"
      },
      "outputs": [],
      "source": [
        "def compute_optimal_dynamic_policy(inverse_demand_func, MAX_QUEUE, NUM_SERVERS, initial_sol, MAX_RATE=1e2, congestion_or_sojourn='congestion'):\n",
        "  negative_func = construct_function(inverse_demand_func, NUM_SERVERS, congestion_or_sojourn)\n",
        "  bounds = [(0, MAX_RATE) for i in range(MAX_QUEUE)]\n",
        "  A = generate_constraint_matrix(MAX_QUEUE)\n",
        "  cons = [{\"type\": \"ineq\", \"fun\": lambda x: A @ x}]\n",
        "\n",
        "  cons = []\n",
        "  res = minimize(negative_func, initial_sol, bounds = bounds, constraints = cons)\n",
        "\n",
        "\n",
        "  if 0 > -1*res.fun:\n",
        "    zero_policy = [0] * MAX_QUEUE\n",
        "    return zero_policy, 0\n",
        "\n",
        "  return res.x, -1*res.fun"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 10,
      "id": "Su8HMXcVb2gt",
      "metadata": {
        "id": "Su8HMXcVb2gt"
      },
      "outputs": [],
      "source": [
        "def get_rev_cost_profit_from_policy(policy, NUM_SERVERS, inverse_demand_func, congestion_or_sojourn):\n",
        "  if policy[0] == 0:\n",
        "    return 0,0,0\n",
        "  steady_state = compute_steady_state(policy, NUM_SERVERS)\n",
        "  pricing_policy = convert_lambdas_to_prices(policy, inverse_demand_func)\n",
        "  rev = np.dot(steady_state[0:-1],np.multiply(pricing_policy,policy))\n",
        "  if congestion_or_sojourn == 'congestion':\n",
        "    cost = np.dot(steady_state, np.arange(len(steady_state)))\n",
        "  if congestion_or_sojourn == 'sojourn':\n",
        "    cost = np.dot(steady_state, np.arange(len(steady_state)))/np.dot(policy,steady_state[0:-1])\n",
        "\n",
        "  profit = rev-cost\n",
        "\n",
        "  return rev,cost,profit"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 11,
      "id": "xIoO0w2GM1zD",
      "metadata": {
        "id": "xIoO0w2GM1zD"
      },
      "outputs": [],
      "source": [
        "def generate_constraint_matrix(n):\n",
        "    A = []\n",
        "\n",
        "    for i in range(n-1):\n",
        "        row = np.zeros(n)\n",
        "        row[i] = 1\n",
        "        row[i+1] = -1\n",
        "        A.append(row)\n",
        "\n",
        "    # Additional constraints to ensure that once we hit zero, all subsequent values are zero\n",
        "    for i in range(n-1):\n",
        "        row = np.zeros(n)\n",
        "        row[i] = 1\n",
        "        row[i+1] = -1e3  # A large number to enforce the zeroing condition\n",
        "        A.append(row)\n",
        "\n",
        "    return np.array(A)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "CNWteUNXLl14",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "CNWteUNXLl14",
        "outputId": "d322b490-eed7-4ea0-f322-9ca6076d8b93"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "0\n",
            "1\n",
            "1\n"
          ]
        },
        {
          "output_type": "stream",
          "name": "stderr",
          "text": [
            "<ipython-input-14-afe527faf49c>:50: DeprecationWarning: Conversion of an array with ndim > 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n",
            "  MAX_QUEUE = (math.ceil(b / a) * NUM_SERVERS + 1)\n",
            "<ipython-input-4-f99e4cc5d6c1>:4: DeprecationWarning: `product` is deprecated as of NumPy 1.25.0, and will be removed in NumPy 2.0. Please use `prod` instead.\n",
            "  denominator = np.sum([np.product(lambda_mu_ratios[0:k]) for k in range(len(lambdas)+1)])\n",
            "<ipython-input-4-f99e4cc5d6c1>:5: DeprecationWarning: `product` is deprecated as of NumPy 1.25.0, and will be removed in NumPy 2.0. Please use `prod` instead.\n",
            "  steady_state = [np.product(lambda_mu_ratios[0:k])/denominator  for k in range(len(lambdas)+1)]\n",
            "<ipython-input-3-ce8a5bed1999>:4: DeprecationWarning: Conversion of an array with ndim > 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n",
            "  prices.append(float(inverse_demand_func(rate)))\n"
          ]
        },
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "2\n",
            "2\n",
            "2\n",
            "2\n",
            "2\n",
            "2\n",
            "2\n",
            "2\n",
            "2\n",
            "2\n",
            "3\n",
            "3\n",
            "4\n",
            "5\n",
            "5\n",
            "6\n",
            "7\n",
            "7\n",
            "8\n",
            "9\n",
            "10\n",
            "11\n",
            "12\n",
            "12\n",
            "12\n",
            "13\n",
            "13\n",
            "14\n",
            "14\n",
            "15\n",
            "15\n",
            "15\n",
            "15\n",
            "15\n",
            "16\n",
            "17\n",
            "18\n",
            "19\n",
            "20\n",
            "20\n",
            "20\n",
            "21\n",
            "22\n",
            "22\n",
            "22\n",
            "23\n",
            "24\n",
            "24\n",
            "25\n",
            "26\n",
            "26\n",
            "26\n",
            "26\n",
            "26\n",
            "27\n",
            "27\n",
            "28\n",
            "28\n",
            "29\n",
            "29\n",
            "29\n",
            "29\n",
            "29\n",
            "30\n",
            "31\n",
            "31\n",
            "31\n",
            "31\n",
            "31\n",
            "32\n",
            "33\n",
            "34\n",
            "34\n",
            "34\n",
            "34\n",
            "34\n",
            "34\n",
            "35\n",
            "36\n",
            "36\n",
            "37\n",
            "37\n",
            "38\n",
            "38\n",
            "39\n",
            "39\n",
            "39\n",
            "40\n",
            "40\n",
            "40\n",
            "41\n",
            "42\n",
            "43\n",
            "44\n",
            "44\n",
            "44\n",
            "45\n",
            "45\n",
            "45\n",
            "45\n",
            "46\n",
            "47\n",
            "48\n",
            "49\n",
            "50\n",
            "50\n",
            "51\n",
            "51\n",
            "52\n",
            "52\n",
            "53\n",
            "53\n",
            "54\n",
            "54\n",
            "55\n",
            "55\n",
            "56\n",
            "57\n",
            "58\n",
            "58\n",
            "58\n",
            "58\n",
            "58\n",
            "59\n",
            "59\n",
            "60\n",
            "60\n",
            "60\n",
            "60\n",
            "60\n",
            "60\n",
            "61\n",
            "62\n",
            "63\n",
            "63\n",
            "63\n",
            "64\n",
            "65\n",
            "65\n",
            "65\n",
            "66\n",
            "67\n",
            "68\n",
            "69\n",
            "69\n",
            "70\n",
            "70\n",
            "71\n",
            "71\n",
            "72\n",
            "72\n",
            "72\n",
            "73\n",
            "73\n",
            "73\n",
            "74\n",
            "74\n",
            "75\n",
            "75\n",
            "76\n",
            "76\n",
            "77\n"
          ]
        }
      ],
      "source": [
        "import numpy as np\n",
        "import time\n",
        "import math\n",
        "from tqdm import trange\n",
        "import pickle\n",
        "\n",
        "# Function to save the results\n",
        "def save_results(results, filename=\"experiment_results.pkl\"):\n",
        "    with open(filename, 'wb') as f:\n",
        "        pickle.dump(results, f)\n",
        "\n",
        "# Function to load the results\n",
        "def load_results(filename=\"experiment_results.pkl\"):\n",
        "    with open(filename, 'rb') as f:\n",
        "        return pickle.load(f)\n",
        "\n",
        "# Initialize or load the results dictionary\n",
        "try:\n",
        "    experiment_results = load_results()\n",
        "except FileNotFoundError:\n",
        "    experiment_results = {}\n",
        "\n",
        "# Function to run a single experiment\n",
        "def run_experiment(demand_type, NUM_SERVERS, num_instances=200, congestion_or_sojourn='sojourn'):\n",
        "    valid_instance_count = 0\n",
        "    degenerate_instances_counter = 0\n",
        "\n",
        "    this_server_experiments = []\n",
        "\n",
        "    blocking_probs = []\n",
        "    optimal_rev_ratios = []\n",
        "    optimal_cost_ratios = []\n",
        "    optimal_profit_ratios = []\n",
        "    elmachtoub_rev_ratios = []\n",
        "    elmachtoub_cost_ratios = []\n",
        "    elmachtoub_profit_ratios = []\n",
        "    optimal_profits = []\n",
        "    optimal_elmachtoub_profits = []\n",
        "    optimal_static_profits = []\n",
        "    ab_vals = []\n",
        "    non_degenerate_ab_vals = []\n",
        "\n",
        "    while valid_instance_count < num_instances:\n",
        "        print(valid_instance_count)\n",
        "        a = np.random.rand(1) * 4.9 + 0.1\n",
        "        b = np.random.rand(1) * 9.5 + 0.5\n",
        "        p0 = np.random.rand(1) * 20\n",
        "\n",
        "        if demand_type == 'linear':\n",
        "            MAX_QUEUE = (math.ceil(b / a) * NUM_SERVERS + 1)\n",
        "            inverse_demand_func = lambda x: (b - x) / a\n",
        "        elif demand_type == 'exponential':\n",
        "            MAX_QUEUE = max(math.ceil(b / a) * 3, NUM_SERVERS)\n",
        "            MAX_QUEUE = 20\n",
        "            inverse_demand_func = lambda x: math.log(b / x) / a if x != 0 else np.array([1e40])\n",
        "        elif demand_type == 'logistic':\n",
        "            MAX_QUEUE = math.ceil(b / a) * 5 * NUM_SERVERS\n",
        "            def inverse_logistic(x):\n",
        "                if abs(x - b) <= 1e-5:\n",
        "                    return np.array([0])\n",
        "                if x == 0:\n",
        "                    return np.array([1e20])\n",
        "                else:\n",
        "                    try:\n",
        "                        return math.log(b * ((1 + math.exp(-a * p0)) / x) - 1) / a + p0\n",
        "                    except ValueError:\n",
        "                        print(x)\n",
        "            inverse_demand_func = inverse_logistic\n",
        "\n",
        "        MAX_RATE = b\n",
        "\n",
        "        # Here you should define the functions compute_optimal_static_policy, compute_optimal_dynamic_policy,\n",
        "        # compute_steady_state, compute_optimal_static_policy_given_rate, get_rev_cost_profit_from_policy\n",
        "        optimal_static_policy = compute_optimal_static_policy(inverse_demand_func, MAX_QUEUE, NUM_SERVERS, MAX_RATE, congestion_or_sojourn)\n",
        "\n",
        "        # Compute the profit for the static policy\n",
        "        opt_static_rev, opt_static_cost, opt_static_profit = get_rev_cost_profit_from_policy(optimal_static_policy, NUM_SERVERS, inverse_demand_func, congestion_or_sojourn)\n",
        "\n",
        "        if opt_static_profit <= 0:\n",
        "            degenerate_instances_counter += 1\n",
        "            continue  # Skip this instance if the static profit is zero\n",
        "\n",
        "        optimal_dynamic_policy, optimal_profit = compute_optimal_dynamic_policy(inverse_demand_func, MAX_QUEUE, NUM_SERVERS, initial_sol=optimal_static_policy, MAX_RATE=b, congestion_or_sojourn=congestion_or_sojourn)\n",
        "        optimal_steady_state = compute_steady_state(optimal_dynamic_policy, NUM_SERVERS)\n",
        "        blocking_probs.append(optimal_steady_state[-1])\n",
        "\n",
        "        if optimal_steady_state[-1] > .01:\n",
        "            print('Max queue needs to be higher')\n",
        "\n",
        "        elmachtoub_rate = np.dot(optimal_steady_state[0:-1], optimal_dynamic_policy)\n",
        "        optimal_elmachtoub_policy = compute_optimal_static_policy_given_rate(inverse_demand_func, MAX_QUEUE, [elmachtoub_rate], NUM_SERVERS, congestion_or_sojourn)\n",
        "\n",
        "        opt_rev, opt_cost, opt_profit = get_rev_cost_profit_from_policy(optimal_dynamic_policy, NUM_SERVERS, inverse_demand_func, congestion_or_sojourn)\n",
        "        opt_elmachtoub_rev, opt_elmachtoub_cost, opt_elmachtoub_profit = get_rev_cost_profit_from_policy(optimal_elmachtoub_policy, NUM_SERVERS, inverse_demand_func, congestion_or_sojourn)\n",
        "\n",
        "        valid_instance_count += 1  # Count valid instances\n",
        "\n",
        "        optimal_profits.append((a, b, opt_profit))\n",
        "        optimal_elmachtoub_profits.append(opt_elmachtoub_profit)\n",
        "        optimal_static_profits.append(opt_static_profit)\n",
        "\n",
        "        elmachtoub_rev_ratios.append(opt_elmachtoub_rev / opt_rev)\n",
        "        optimal_rev_ratios.append(opt_static_rev / opt_rev)\n",
        "        elmachtoub_cost_ratios.append(opt_elmachtoub_cost / opt_cost)\n",
        "        optimal_cost_ratios.append(opt_static_cost / opt_cost)\n",
        "        elmachtoub_profit_ratios.append(opt_elmachtoub_profit / opt_profit)\n",
        "        optimal_profit_ratios.append(opt_static_profit / opt_profit)\n",
        "\n",
        "        non_degenerate_ab_vals.append([a, b])\n",
        "        ab_vals.append([a, b])\n",
        "\n",
        "    if demand_type not in experiment_results:\n",
        "        experiment_results[demand_type] = {}\n",
        "\n",
        "    experiment_results[demand_type][NUM_SERVERS] = {\n",
        "        'blocking_probs': blocking_probs,\n",
        "        'optimal_rev_ratios': optimal_rev_ratios,\n",
        "        'optimal_cost_ratios': optimal_cost_ratios,\n",
        "        'optimal_profit_ratios': optimal_profit_ratios,\n",
        "        'elmachtoub_rev_ratios': elmachtoub_rev_ratios,\n",
        "        'elmachtoub_cost_ratios': elmachtoub_cost_ratios,\n",
        "        'elmachtoub_profit_ratios': elmachtoub_profit_ratios,\n",
        "        'optimal_profits': optimal_profits,\n",
        "        'optimal_elmachtoub_profits': optimal_elmachtoub_profits,\n",
        "        'optimal_static_profits': optimal_static_profits,\n",
        "        'ab_vals': ab_vals,\n",
        "        'non_degenerate_ab_vals': non_degenerate_ab_vals,\n",
        "        'degenerate_instances_counter': degenerate_instances_counter\n",
        "    }\n",
        "\n",
        "    # Save the results after each run\n",
        "    save_results(experiment_results)\n",
        "    print(f\"Experiment for demand_type={demand_type} and NUM_SERVERS={NUM_SERVERS} completed and saved.\")\n",
        "\n",
        "# Example usage\n",
        "demand_type = 'linear'\n",
        "NUM_SERVERS = 1\n",
        "model_type = 'sojourn'\n",
        "num_instances = 1000\n",
        "run_experiment(demand_type, NUM_SERVERS, num_instances, model_type)\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "IwPszI_tg2dD",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "IwPszI_tg2dD",
        "outputId": "c92cf3b0-1378-4171-c720-8cedec1c7da9"
      },
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "0.9998945409236935"
            ]
          },
          "metadata": {},
          "execution_count": 13
        }
      ],
      "source": [
        "np.min(experiment_results['linear'][10]['optimal_profit_ratios'])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "dBPx3CTJvHuv",
      "metadata": {
        "id": "dBPx3CTJvHuv"
      },
      "outputs": [],
      "source": []
    }
  ],
  "metadata": {
    "colab": {
      "provenance": [],
      "gpuType": "T4"
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.10.4"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}
